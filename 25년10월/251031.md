# 251031



- BeanWrapper
  - Spring 프레임웤의 펀더멘탈
  - 직접 사용할 일은 X
- DataBinder
  - user input이 동적으로 도메인 모델로 묶는데 사용
  - 단순히 Web-Layer에만 국한 X
- PropertyEditorSupport / PropertyEditor 
  - Java Bean Spec



---



- Validator / Errors

  - Spring에서 Object Validation 할때 사용

  ```
  public class Person {
  
  	private String name;
  	private int age;
  
  	// the usual getters and setters...
  }
  
  // 위 클래스를 Validation하기 위해 아래처럼 Spring에서 제공하는 Validator를 구현하는 Validator를 작성 가능
  ```

  

- 중첩 객체에 대해서는 하나의 Validator가 처리할 수 있지만, 개별 Validator를 구현하는게 낫다





---





### JVM과 OS의 메모리구조

- OS의 메모리영역

  - Stack영역 / Heap영역 / Data영역 / Text영역
  - <img width="1280" height="720" alt="Image" src="https://github.com/user-attachments/assets/20b24caa-d831-4647-aec6-5acfeaebe62f" />

- JVM의 메모리구조

  - Method Area / Heap / Stack / Native Method Stack

    - Method Area의 구현체가 Java 8 이전에는 PerGem이었다가 Java 8이후부턴 MetaSpace영역으로 교체

    - MetaSpace는 Heap영역에서 떨어져 나왔으며 조금더 구체적인 Pergem과 비교는 아래와 같다.

      <img width="1200" height="514" alt="Image" src="https://github.com/user-attachments/assets/e0a6ead2-2447-4dba-8354-43726e90ef26" />

  

  <img width="711" height="776" alt="Image" src="https://github.com/user-attachments/assets/d61252c0-0ff0-46a3-81a7-555abbfd9681" />

  

  ---

  

  ### OS의 Stack,Heap영역과 JVM의 Stack Heap영역은 어떻게 다를까?

  먼저 짚고 넘어갈 것은 JVM의 메모리 저장공간은 독립적으로 존재하는 Physical한 영역이 아니다.

  다시 말하자면, OS가 JVM이라는 프로세스에 할당한 메모리 공간 위에 어딘가에 저장되는 것이다.

  

  지속적으로 OS와 JVM의 메모리영역에 대해서 용어가 계속해서 헷갈리지만, JVM내의 데이터를 저장하는 공간인 Runtime Data Area에 저장되는 모든 것은 사실상 OS의 메모리의 특정 메모리 주소공간에 저장되는 것일 뿐이다. 

  

  즉, JVM의 메모리 구조는 OS가 제공하는 물리적 메모리 위에 논리적으로 구성된 가상 메모리 영역

  

  즉, JVM 내부의 RuntimeData area의 Heap, Stack, MetaSpace(Method Area), PC Register등은 JVM이 논리적으로 구분한 영역이다. 

  

  1. OS의 Stack과 JVM의 Stack 영역

     - OS Stack
       - 커널이 Native Thread 실행을 위해 관리하는 영역
     - JVM Stack
       - JVM 내부에서 각 Java Thread 호출 프레임을 관리
     - HotSpot JVM 기준으로 Java Thread 하나가 Native Thread 한 개로 맵핑된다. 
       - JVM Stack영역은 '개념적' 영역이며, 실제 메모리는 OS의 네이티브 Stack영역을 사용한다.

  2. OS의 Heap영역과 JVM의 Heap영역

     - OS Heap
       - C/C++에서 malloc()등을 통해서 동적 메모리를 할당받을떄 사용되는 Native Heap영역
     - JVM Heap
       - OS Heap과 별도로 JVM이 OS로부터 일정한 크기의 메모리 블록을 할당받아 관리하는 영역

     - JVM 자체에 대한 간단한 이해가 먼저 필요

       - OS관점에서 JVM도 C/C++로 작성된 프로세스이고 다른 프로세스와 동일하게 취급	된다.

       - 상단의 JVM내의 데이터들이 저장되는 메모리 영역인 RuntimeData Area에서 Heap영역을 제외하곤 대부분 OS와 

  

  StackOverFlow의 관련 글에서 답변글을 참조하자면 아래와 같다.

  

```
Again there is no magic. The JVM heap is a region of memory, a JVM stack is the same a native stack which is what C+ uses, the JVM's registers is the same as native registers which is what C+ uses and JVMs thread are actually native threads which is what C+ uses.
```

참고 : https://stackoverflow.com/questions/16264118/how-jvm-stack-heap-and-threads-are-mapped-to-physical-memory-or-operation-syste



도식화 해보자면 아래와 같다.



| JVM 논리 영역                    | OS 관점에서의 실제 위치                            | OS와의 관계                       |
| -------------------------------- | -------------------------------------------------- | --------------------------------- |
| **Java Heap**                    | OS의 가상 주소 공간 내 `mmap`으로 확보한 독립 구간 | OS는 공간만 제공, GC는 JVM이 관리 |
| **Metaspace (Method Area)**      | `mmap`으로 확보된 또 다른 구간                     | OS의 일반 힙과 별개, JVM 전용     |
| **JVM Stack (자바 스레드 스택)** | 각 OS 스레드의 실제 스택 메모리                    | ✅ OS 스택과 직접 연결             |
| **Native Method Stack**          | OS 스레드 스택 중 JNI 프레임 부분                  | ✅ OS 스택 내에서 사용             |
| **PC Register**                  | CPU 레지스터 레벨                                  | OS 스레드와 동일하게 동작         |



참고 : 

https://lxxyeon.tistory.com/70

https://woojoovove.tistory.com/36

https://jaemunbro.medium.com/java-metaspace%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-ac363816d35e

