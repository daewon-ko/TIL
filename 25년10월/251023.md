# 251023



### UserDetailService를 왜 Implement를 해야할까?





### WebMvcConfiguerer





### 영속성 컨텍스트 더티체킹

JPA를 사용하다 Mybatis를 사용하다 번갈아 이용하니 약간 헷갈렸다.

- save()를 꼭 해야할까?

```
@Transactional
fun(){
User user = findById(userID);

user.setXXX();

// 아래 코드는 필수일까?
userRepository.save(user);	
}

```

위에서 findById(userId)를 하는 순간 영속성 컨텍스트에 관리되게 된다. 

따라서 setXXx를 하면 flush하기 전에 더티체킹이 발생하므로 별도로 save()를 작성할 필요가 없다. 



또 다음과 같은 상황을 생각해보자. 	



```
@Transactional
fun(){
	
	User user = User.buillder.xxx..();
	
 	User savedUser = userRepository.save(user); // save치는 순간 영

	Product product = Product.builder().userId(savedUser.getId())...();
	
	
	savedUser.setXXX(); 
	
}
```

위와 같은 상황에서는 Insert쿼리는 어느 시점에 수행될까? 

-> ID 생성전략과 Flush 타이밍에 따라 다르다. 

1. @GeneratedValue(strategy = IDENTITY)

   - save()하는 순간에 바로 DB에 INSERT쿼리를 수행
     - <- ID값 자체를 DB에서 생성하므로, Hibernate가 즉시 flush를 수행
   - setXXX();
     - UPDATE 쿼리가 해당 트랜잭션이 종료되기 함께 수행

2. @GeneratedValue(strategy = SEQUENCE | TABLE | UUID ) 등

   - save() 시점에 INSERT가 즉시 필요하지 않음

     - <- SEQUENCE는 미리 시퀀스에서 ID를 가지고 올수 있으므로 Flush시점으로 쿼리 수행을 지연

     - UUID역시 Application에서 생성해서 찍을 경우에 가능

       - CF) 아래처럼 생성할경우 Application단(JPA / Hibernate)에서 UUID를 생성한다.
         - DB에서 직접 UUID를 생성할때

       ```
           @Id
           @GeneratedValue(generator = "UUID")
           @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator")
           @Column(name = "id", updatable = false, nullable = false, columnDefinition = "uuid")
           private UUID id;
       
       ```

   - setXXX()

     - 마지막 Flush시점에 한번에 INSERT쿼리를 수행



또 @Transactional과 영속성컨텍스트의 Flush시점의 차이는 어떻게 다를까? 

-> FLUSH는 영속성 컨텍스트에서 관리되는 객체들의 변경내용을 DB에 미뤄넣는 시점

FLUSH != 커밋

커밋은 실제 DB에서 수행되는 작업이고 커밋이 확정되야 실제로 DB에 반영된다. 