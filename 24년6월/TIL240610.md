# TIL240610

### 알고리즘 - 그래프

* 방향있는 그래프 / 방향없는 그래프
  * 방향 없는 -> 양 노드에서 서로 이동할 수 있다.
  * 방향 있는 -> 노드에서 노드로 이동할 때 특정한 '방향'으로만 이동 가능하다.

### BFS, DFS와 같은 그래프 탐색 시에 visited 배열을 생성해줄때 무엇을 기준으로 visited를 1차원 혹은 2차원 그래프로 생성해주는가? 

* 격자열 배열을 생성해야만 하는 경우
  * 좌우상하, 위 아래와 같이 움직여야하는 그래프를 생성해야한다면, 
    visited배열 역시 graph 배열과 같이 생성해줘야 할것이다. 
* 그러나, Node를 중점으로 방문여부만을 탐색할경우엔 2차원배열을 생성할 필요는 없다.



### 자바문법

하단의 코드의 예에서 제네릭을 붙일경우 컴파일 에러가 발생하는 이유는?

```
List<Integer> [] list = new ArrayList<>[1000]; // 컴파일 에러
List<Integer> [] list = new ArrayList [1000]; // 정상

```

> 배열과 제네릭의 타입 정보
> 배열:
>
> 컴파일 타임과 런타임 모두에서 타입 정보를 유지합니다.
> 배열은 생성 시점에 타입이 고정되며, 컴파일러는 이를 기반으로 타입 안전성을 체크합니다.
> 예를 들어, new String[10]은 항상 String 타입만 허용하며, 다른 타입을 넣으려 하면 컴파일 에러가 발생합니다.
> 제네릭:
>
> 컴파일 타임에만 타입 정보를 사용하며, 런타임에는 타입 소거(Type Erasure)가 발생합니다.
> 즉, 제네릭 타입 정보는 런타임에 제거되고 원시 타입으로 변환됩니다.
> 예를 들어, List<Integer>는 런타임에 List로 변환되며, 타입 정보는 유지되지 않습니다.
> 컴파일 에러의 원인
> 제네릭 배열 생성 시 컴파일 에러
> java
> 코드 복사
> List<Integer>[] list = new ArrayList<>[1000]; // 컴파일 에러
> 이 구문에서 컴파일러는 제네릭 배열을 생성하는 것이 안전하지 않다고 판단하여 컴파일 에러를 발생시킵니다. 그 이유는:
>
> 타입 소거로 인한 타입 안전성 문제:
>
> 제네릭은 런타임에 타입 정보를 유지하지 않기 때문에 List<Integer>[]를 생성하면 타입 안전성을 유지할 수 없습니다.
> 예를 들어, List<Integer>[] 배열이 런타임에 단순히 List[]로 다뤄지며, 이로 인해 다른 타입이 들어올 수 있습니다.
> 배열의 공변성 문제:
>
> 배열은 공변성(Covariance)을 가지고 있습니다. 즉, Number[]는 Integer[]로 사용할 수 있지만, 제네릭에서는 이와 같은 방식으로 타입을 사용할 수 없습니다.
> 제네릭 타입을 배열로 사용하면 타입 안전성을 보장하기 어렵기 때문에 컴파일러는 이를 허용하지 않습니다.
> 비제네릭 배열 생성
> java
> 코드 복사
> List<Integer>[] list = new ArrayList[1000]; // 정상 (하지만 경고)
> 이 코드는 제네릭을 사용하지 않고 단순히 비제네릭 배열을 생성합니다. 하지만:
>
> 컴파일러는 제네릭 배열이 아니라 ArrayList 배열을 생성하여 타입 안전성 문제를 피합니다.
> 이 경우에도 배열의 요소 타입이 List<Integer>가 아닌 ArrayList이기 때문에 타입 안전성을 완전히 보장할 수 없으며, 경고를 받을 수 있습니다.
> 강제 형변환
> java
> 코드 복사
> List<Integer>[] list = (List<Integer>[]) new ArrayList[1000]; // 경고
> 강제 형변환을 사용하여 제네릭 배열을 생성할 수 있지만:
>
> 런타임에 타입 안전성을 보장할 수 없습니다.
> 컴파일러는 여전히 경고를 발생시켜, 개발자가 이 접근 방식의 위험성을 인식하도록 합니다.
> 핵심 요약
> 배열은 런타임에 타입 정보를 유지하고, 제네릭은 런타임에 타입 정보를 소거합니다.
> 컴파일러는 제네릭 배열 생성을 허용하지 않아 타입 안전성을 유지합니다.
> 제네릭 배열을 생성하고자 하면 강제 형변환을 사용해야 하지만, 이는 런타임에 타입 안전성을 보장할 수 없고 경고를 발생시킵니다.
> 이러한 이유로 Java는 제네릭 배열 생성을 금지하여 타입 안전성을 유지하려고 합니다.



### 1대 1 채팅 문의 기능

쇼핑몰 API를 만드는데, 1대 1 채팅 문의 기능을 구현해야한다. 

해당 기능은 어떠한 세부 요소로 나눌 수 있을까? 

1. 고객(편의상 구매자)가 판매자에게 문의를 한다.
   1. POST 요청으로 채팅방(ChatRoom)을 생성한다.
      - 문의 글을 남기면 자동으로 채팅방이 생성된다. 
      - 'ENTER'로 들어가면 채팅방이 생성되고 자동으로 입장된다.(WebSocketSessiond으로 해당여부 확인해야할듯)
   2. 채팅방에 
2. 고객과 판매자는 서로 대화를 할 수 있다. 





### 채팅 기능 관련 DB(ERD) 구축 문제

Entity 

1. ChatRoom

   1. 채팅방은 User(사용자)와 어떠한 관계?
      - 고객, 판매자가 있으므로 하나의 채팅방에는 두 명의 User가 들어간다. 
        - 1대1채팅만을 고려할때, CharRoom이 User에 관해서 다대일관계를 갖는 거이 적절할까?
      - 그러므로 1대 다 관계를 상정해야할까? 
   2. User는 여러 개의 채팅방을 갖을 수 있다.(User Entity 입장에서는 1대다 관계)

2. Message

   
