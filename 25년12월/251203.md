# 251203



### Spring Batch ItemReader의 read()메서드

- Spring Batch에서는 Step의 한 구성요소로서 ItemReader가 있다.

- ItemReader라는 Batch가 제공하는 인터페이스를 구현해서 사용하느데, Batch모듈 내에 여러 구현체가 존재한다.

  - ex)MyBatisPagingItemReader, MyBatisCursorItemReader, JpaItemReader등..(ORM도 있고 순수 jdbcTemplate관련 Reader 구현체도 있음)

- 대부분 read() 메서드가 호출될때마다 실제 I/O가 일어날까?

  - 이는 구현체마다 모두 다르다. 

  - 1. Cursor계열

       1. ```
          ### 2-1. Cursor 계열 (JdbcCursorItemReader, MyBatisCursorItemReader 등)
          - 특징:
            - **쿼리를 한 번만 실행해서 커서를 열어두고**, `read()` 호출할 때마다 DB 커서에서 **다음 row를 순차적으로 꺼내오는 방식**.
          - I/O 패턴:
            - 쿼리 실행은 **1번**
            - 그 이후 read()는 ResultSet/커서에서 한 줄씩 뽑아오는 형태
            - 네트워크 레벨에서는 DB 커서 프로토콜에 따라 chunk로 받아오지만, 개발자가 `read()` 호출할 때마다 SQL이 다시 나가는 건 아님.
          ```

    2. Paging계열

       1. ```
          Paging 계열 (JdbcPagingItemReader, MyBatisPagingItemReader, JpaPagingItemReader 등)
          
          
          - 설정 예:
            - `pageSize = 100`
            - 쿼리는 내부적으로 `LIMIT / OFFSET` 혹은 key 기반 페이징 등으로 구성
          
          동작 방식:
          
          1. 첫 번째 페이지 로딩 시:
             - 한 번 쿼리 실행:
                예) `SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT 100 OFFSET 0`
             - 그 결과를 **메모리에 리스트로 들고 있음**.
          2. 그 다음 `read()` 호출들:
             - 메모리에 있는 리스트에서 하나씩 꺼내서 반환
             - 리스트가 다 소진되면:
               - 다음 페이지 필요 시 또 쿼리 실행
                  예) `LIMIT 100 OFFSET 100`
          3. 데이터가 총 3건이고 pageSize=100이면:
             - **딱 한 번만 쿼리 실행**해서 3건 다 가져오고
             - `read()` 3번은 메모리에서 꺼내주는 것뿐.
          
          그래서 여기서도 마찬가지:
          
          > read() 3번 호출된다고 해서 쿼리가 3번 나가는 게 아니라,
          >  **최대 “페이지 수만큼” 쿼리가 나간다고 보는 게 맞다.**
          ```

    3. 커스텀 구현체

       1. ```
          2-3. 완전 커스텀 ItemReader (네가 직접 구현하는 경우)
          
          네가 직접 `ItemReader<T>` 를 구현하면 I/O 패턴은 **네 마음대로** 설계할 수 있어.
          
          예를 들어:
          
          1. **초기 한 번만 DB/외부 API 호출해서 List 캐싱**:
          
             ```
             public class CachedItemReader implements ItemReader<Foo> {
             
                 private List<Foo> buffer;
                 private int index = 0;
             
                 @Override
                 public Foo read() {
                     if (buffer == null) {
                         // 여기서 단 한 번만 DB/외부 API 호출
                         buffer = repository.findAllFoo();
                     }
                     if (index >= buffer.size()) {
                         return null;
                     }
                     return buffer.get(index++);
                 }
             }
             ```
          
             - I/O(쿼리)는 **read() 최초 호출 시 한 번만**.
             - 이후 read()는 전부 메모리에서만 읽음.
          
          2. 매번 i/O가 발생하는경우
          
             ```
             public class DumbItemReader implements ItemReader<Foo> {
             
                 private int offset = 0;
             
                 @Override
                 public Foo read() {
                     Foo item = repository.findOneWithOffset(offset);
                     if (item == null) return null;
                     offset++;
                     return item;
                 }
             }
             ```
          ```



- 위에서 보듯이 readCount와 I/O 작업의 단위는 일치하지 않는다.

  -  reader는 ItemReader의 어떤 구현체를 사용하느냐에 따라서

    - Paging쿼리를 사용할 수도 Cursor기반 페이징을 사용할 수도 있고 

    - 아니면 아무론 조건 없이 쿼리를 수행할 수도 있다.

      



---

### StepExecution getWriteCount()

```
    @Test
    @DisplayName("Job 실행하면 step1과 step2이 순차적으로 실행되어 배치가 완료된다")
    void testIntegration_ExecuteJob() throws Exception {
        // Given: 테스트 데이터 준비
        insertBulkTestLogs(5); // 5건 삽입

        JobParameters jobParameters = new JobParametersBuilder()
                .addLong("timestamp", System.currentTimeMillis())
                .toJobParameters();

        // When: 전체 Job 실행
        JobExecution jobExecution = jobLauncherTestUtils.launchJob(jobParameters);

        // Then: Job이 정상 완료되어야 함
        assertThat(jobExecution.getExitStatus().getExitCode()).isIn("COMPLETED", "COMPLETED_WITH_SKIPS");
        assertThat(jobExecution.getStatus()).isEqualTo(BatchStatus.COMPLETED);

        // Step 실행 검증

        StepExecution step1 = jobExecution.getStepExecutions().stream()
                .filter(se -> "step1".equals(se.getStepName()))
                .findFirst()
                .orElseThrow(() -> new AssertionError("syncNonFaceCardIssueStep 찾을 수 없습니다."));

        assertThat(step1.getReadCount()).isEqualTo(5);
        assertThat(step1.getWriteCount()).isEqualTo(5);
        assertThat(step1.getProcessSkipCount()).isEqualTo(0);
        assertThat(step1.getWriteSkipCount()).isEqualTo(0);
        assertThat(step1.getCommitCount()).isEqualTo(1);


        StepExecution step2 = jobExecution.getStepExecutions().stream()
                .filter(se -> "step2".equals(se.getStepName()))
                .findFirst()
                .orElseThrow(() -> new AssertionError("notifyFailStep를 찾을 수 없습니다."));

        assertThat(step2.getReadCount()).isGreaterThanOrEqualTo(0);
        assertThat(step2.getWriteCount()).isEqualTo(0);
        assertThat(step2.getProcessSkipCount()).isEqualTo(0);
        assertThat(step2.getWriteSkipCount()).isEqualTo(0);
        assertThat(step2.getCommitCount()).isEqualTo(1);


    }
```

- 위의 예시에서 getWriteCount()를 하는데
  - Write()는 물리적으로 1회 실행된다. (예외가 발생하지 않는한, 배치 구조에서는)
  - 그러나, StepExecution의 getWriteCount는 Write로 영향을 받는 Item수가 Return된다.
- CF) Write호출 횟수
  - ItemWriter.write(Chunk<? extends T> chunk)
    - chunk마다 1회 호출
  - Item3개 / chunkSize100이면
  - write()메서드 자체는 호출됨
  - 즉, 위의 StepExectuion.getWriteCount()와 ItemWrtier가 write()를 호출하는 횟수는 다름



### ItemReader의 read()와 StepExectuion의 readCount



- Spring Batch의 청크 루프는 아래와 같이 돌아감(러프하게)

  - chunkSize가 100 / Item개수가 3개라면?

  ```
  int count = 0;
  T item;
  while (count < chunkSize && (item = reader.read()) != null) {
      // process(item) ...
      count++;
  }
  ```

- `reader.read()`:

  - 1번째 호출 → 아이템1
  - 2번째 호출 → 아이템2
  - 3번째 호출 → 아이템3
  - 4번째 호출 → `null` → 루프 종료

  - **read() 호출 횟수 = 아이템 수(3) + 마지막 null 한 번(1) = 4번**
