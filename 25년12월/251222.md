# 251222



### Batch Application 에서 System.exit()으로 마무리하는게 좋은 이유?



- 통상 Batch Application은 CI 툴 등과 통합되어 사용

  - exit_code

  - ```
    int code = SpringApplication.exit(context); // 여기서 code 계산
    System.exit(code);                          // OS에 전달하며 종료
    
    ```

  - SpringApplication.exit(context)

    - context안에 등록된 ExitCodeGenerator들을 조회
      - Batch에서는 JobExecutionCodeGenerator
      - ![image-20251222110759597](D:\Typora\images\image-20251222110759597.png)

- System.exit()을 사용할 경우 JobExecutionCodeGenerator가 동

  - 이를 통해 DB에 기록된 배치상태와 실제 프로세스의 종료 상태가 일치를 확인



---

### Tasklet에서 RepeatStatus로 메서드 실행 반복여부를 결정하는 이유

- Spring Batch는 (Tasklet 기준으로 ) execute() 호출마다 새로운 트랜잭션을 시작하고, execute()의 실행이 끝나 RepeatStatus가 반환되면 해당 트랜잭션을 커밋
  - 따라서 , execute()내부에서 While문으로 코드를 작성할 경우에 모든 시도가 하나의 트랜잭션으로 묶이게 된다. 
  - ex) 80만 건째 처리 중 예외가 밠애하면, 이미 처리한 79만건의 데이터도 모두 롤백된다.

###  ResourceLessTransactionManager

- Tasklet에서 트랜잭션 처리가 필요하지 않을경우에 PlatformTransactionManager대신에 사용할 수 있음

```
    @Bean
    public Step zombieProcessCleanupStep() {
        return new StepBuilder("zombieProcessCleanupStep", jobRepository)
                .tasklet(zombieProcessCleanupTasklet(), new ResourcelessTransactionManager())
                .build();
    }
```



---



### JobParameters 전달



```
./gradlew bootrun --args='--spring.batch.job.name=dataProcesingJob inputFilePath=/data/input/users.csv,java.lang.String'
```

- --spring.batch.job.name으로 전달도니 job이름 뒤에 딸려오는 것이 JobParameter이다.
- Key=value, Parameter Type순서대로 정의

```
parameterName=parameterValue,parameterType,identificationFlag
```



- parameterName

  - 배치 Job에서 파라미터를 찾을때 사용하는 Key 값

- parameterValue

  - 파라미터의 실제 값

- paramterType

  - 파라미터 타입
    - FQCN을 사용
    - 명시하지 않을 시에는 Spring Batch에서 'String' Type을 기본값으로 사용
    - Spring Batch의 '**DefaultJobParametersConverter**'라는 컴포넌트를 통해 적절한 타입으로 변환됨

- identificationFlag

  - 해당 파라미터가 JobInstance 식별(identification)에 사용될 파라미터인지 여부를 전달하는값으로 'true'이면 식별에 사용된다는 의미
  - 생략 가능
    - 생략 시 true로 설정

- 종류

  - **문자열 대입(String Type)**

    

    ```
    ./gradlew bootRun --args='--spring.batch.job.name=processTerminatorJob terminatorId=KILL-9,java.lang.String targetCount=5,java.lang.Integer'
    
    ```

  - **날짜 Type대입**(LocalDate, LocalDateTime)

    ```
    ./gradlew bootRun --args='--spring.batch.job.name=terminatorJob executionDate=2025-12-22,java.time.LocalDate startTime=2025-12-22T14:30:00,java.time.LocalDateTime
    ```

    - executionDate는 'yyyy-MM-dd' / startTime은 'yyyy-MM-ddThh:mm:ss'형식 사용
    - DateTimeFormatter의 ISO_LOCAL_DATE와 ISO_LOCAL_DATE_TIME형식과 일치

  - **열거형(ENUM)타입 전달**

    ```
    ./gradlew bootRun --args='spring.batch.job.name=terminatorJob questDifficulty=HARD,com.system.batch.killBatchSystem.TerminatorConfig$QuestDifficulty'
    ```

    - '**$'** 기호가 들어있음
      - QuestDifficulty enum이 TerminatorConfig 클래스 안에 Nested Class로 정의했기 때문

  - **POJO 주입**

    ```
    package com.system.batch.killbatchsystem.parameters;
    
    import lombok.Data;
    import org.springframework.batch.core.configuration.annotation.StepScope;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.stereotype.Component;
    
    @Data
    @StepScope
    @Component
    public class SystemInfiltrationParameters {
    
        @Value("#{jobParameters[missionName]}")
        private String missionName; // 필드 주입
        private int securityLevel;
        private final String operationCommander;
    
        // 생성자 주입
        public SystemInfiltrationParameters(@Value("#{jobParameters[operationCommander]}") String operationCommander) {
            this.operationCommander = operationCommander;
        }
    
    
        // setter 주입
        @Value("#{jobParameters[securityLevel]}")
        public void setSecurityLevel(final int securityLevel) {
            this.securityLevel = securityLevel;
        }
    }
    
    ```

  - ```
    ./gradlew bootRun --args='spring.batch.job.name=terminatorJob missionName=어쩌구,java.lang.String operationCommander=KILL-9 securityLevel=3,java.lang.Integer,false'
    ```

    - missionName과 operationCommander는 String Type, identifying=true로 설정되어 job인스턴스 식별에 사용
      - jobParameter의 기본 타입은 String이므로 생략가능

### JobParameter 파라미터 값에 '쉼표(,)'가 포함된다면? 

-> Spring Batch 5부터는 JSON기반 파라미터 표기법 새롭게 제공

- 의존성 추가

```
    implementation 'org.springframework.boot:spring-boot-starter-json'

```

- jobParametersConverter를 새롭게 Bean으로 등록

```java
    @Bean
    public JobParametersConverter jobParametersConverter() {
        return new JsonJobParametersConverter();
    }

```

- jobparameter는 아래와 같이 작성가능

  ```java
  infiltrationTargetrs= '{"value" : "가산,서버실", "type" : "java.lang.String"}'
  ```

- 1. bootRun 태스크 실행

  ```
  ./gradlew bootRun --args="'--spring.batch.job.name=terminatorJob infiltrationTargets='{\"value\" :\"가산, 서버데이터실\", \"type\" : \"java.lang.String\"}'"
  
  
  ```

  2. java -jar 명령어 실행

     - java -jar 명령어로 직접 애플리케이션을 실행할때는, 아래와 같이 JSON 파라미터 표기법을 그대로 사용

     ```
     java -jar kill-batch-system-0.0.1-SNAPSHOT.jar --spring.batch.job.name=terminatorJob infiltrationTargets='{"value" : "가산,데이터센터", "type" : "java.lang.String"}'
     ```

  3. Intelij등 에서는 아래와 같이 작성가능

  ```
  --spring.batch.job.name=terminatorJob infiltrationTargets={\"value\":\"판교_서버실,안산_데이터센터\",\"type\":\"java.lang.String\"}
  
  ```

  

### JobLauncherApplicationRunner

- SpringBoot가 제공하는 ApplicationRunner의 한 종류
  - CommandLine으로 전달된 Spring Batch Job Parameter를 해석하고 이를 바탕으로 실제 Job을 실행
- 1. Job 목록 준비
     1. Spring Boot에 의해 ApplicationContext에 등록된 모든 job Type의 Bean이 JobLauncherApplicationRunner에 자동 주입
  2. 유효성 검증
     - ApplicationContext에 Job Type의 빈이 여러개일때, --spring.batch.job.name을 지정하지 않으면, 검증 실패
     - job Type의 빈이 하나만 있으면 --spring.batch.job.name을 생략 가능
  3. 명령어 해석
     - key=value 형식의 인자들을 JobParameters로 변환한다.
     - 이 과정에서 DefaultJobParametersConverter(JsonJobParametersConverter)가 사용됨
  4. Job 실행
     - --spring.batch.job.name에 해당하는 job을 찾음
     - 해당하는 Job을 앞서 변환된 JobParameters와 함께 실행되며 이 과정에서 JobLauncher라는 Job을 실행시키는 컴포넌트가 사용됨

### 커맨드라인 외에도 다양한 방식으로 배치를 실행할때가 있음

- REST API를 통해 외부 시스템에서 배치 작업을 트리거할떄
- MQ에서 메시지가 도착했을때
- 특정 비즈니스 이벤트가 발생했을때(파일업로드 완료,  주문처리 완료  등)
- @Scheduled 태스크에서 동적 파라미터와 함께 배치를 실행해야하는 경우



-> 위와 같은 방식에서는 프로그래밍 방식으로 JobParameters를 생성하고 전달















- @StepScope
  - @Value를 사용해서 JobParameter를 받으려면 @StepScope와 같은 어노테이션 선언 필요











