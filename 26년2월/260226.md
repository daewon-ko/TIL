# 260226







###  filesort

-  explain 명령어로 실행계획을 확인했는데, 'Extra' 컬럼에 Using FileSort가 나오는것을 종종확인

- 인덱스를 타지 못하고 MYSQL 메모리 또는 디스크에서 정렬하는 것을 뜻함.
  - 인덱스를 타지 못하기 때문에 CPU를 추가적으로 사용하고 메모리 사용이 증가. 
  - 경우에 따라 I/O가 증가 가능.
- sort_buffer_size가 초과하면 디스크에서 정렬수행 가능
- 즉 filesort라고 반드시 디스크에서 정렬을 수행한다는 뜻은 아님





---



### ORDER BY INDEX

- orderBy 대상 컬럼에 인덱스 X
  - File Sort라는 임시테이블을 이용한 추가정렬 필요
  - 정렬되어야하는 데이터가 적다면 -> 메모리 수준에서 Sort Buffer를 통해 처리
  - Sort Buffer보다 데이터의 양이 많다면 데이터들을 쪼개서 디스크에 저장한 후 각각 정렬하고 합치는식
-  Order By 이하의 인덱스 O
  - 정렬 작업 불필요
  - Order By이하의 인덱스가 없다면, 전체 모든 데이터를 정렬한 이후에 LIMIT절 만큼 잘라서 추출함
    - 이에 따라 성능차이가 많이 발생
  - 따라서 기본적으로는 ORDER BY 이하 컬럼에 대해서 인덱스가 걸려있는게 성능 상 큰 이점을 제공

 

### ORDER BY 이하에 INDEX를 생성하지 못한다면?

- 우선 왜 Index를 OrderBY이하에 생성하지 못할까?
  - 이미 기존에 INDEX가 생성이 많이 되어있는 경우에
    - UI의 검색조건이 많아지면 모든 검색조건에 대해서 인덱스를 생성하는건 현실적으로 불가능하다.
    - 쓰기시마다 INDEX 생성 비용이 증가한다.
  - 현실적으로 모든 정렬을 INDEX로 해결할 수 없기때문에
  - GROUP BY / JOIN 정렬은 어차피 filesort를 타기때문에

- FileSort를 사용할 확률이 높다.
- FileSort를 사용함에도 성능을 향상시킬 수 있는 방법은?
  - sort_buffer_size 튜닝
  - Singple-Pass에서 Two-Pass로 튜닝



### ORDER BY 사용시, 결과값이 달라지는 문제

- 단순히 ORDER BY절 이하에 특정 컬럼 값만 명시할 경우에 쿼리의 결과가 '비결정적'일 수 있다.

  - <- ORDER BY 컬럼의 대상이 'age'라고 할때, age가 30명인 사람이 5명이 있다면 5명의 순서는 누가 먼저 나올까?

  ```
  SELECT * 
  FROM member
  ORDER BY age;
  ```

  - Optimizer는 age가 같은 것에 대해서 어떻게 배치할지는 보장하지 않는다.
    - orderby 대상 컬럼에 인덱스가 걸려있으면 이걸 이용할 수도 있고 아니면, filesort를 사용할 수도 있다.

- 문제는 **ORDER BY가 LIMIT과 같이 사용될 때**이다.

  ```
  SELECT * 
  FROM member
  ORDER BY age
  LIMIT 10;
  ```

  - age가 같은 값이 경계에 걸려있다면?
  - 어떤 실행에서는 A가 나오고 어떤 실행에서는 B가 나올 수 있다 
  - -> **페이징에서 중복/누락 문제가 발생**한다.

- order by에서 항상 같은 순서를 보장하려면 

  - ORDER BY절 이하에 PK를 명시해줘야함.
  - ORDER BY age, id
    - age가 같은 것에 대해서는 PK로 정렬한다.
    - PK는 클러스터드인덱스이므로 내부적으로 정렬이 이미 되어있음. 

### 

### 왜 카디널리티가 높은 컬럼에 인덱스를 먼저 걸어야할까?

- 상식적으로 생각하면 너무 자명
-  GENDER와 같이 'M' 또는 'F'이면 데이터가 1000만건이어도 카디널리티는 2로 고정
  - GENDER를 조건을 걸어서 조회를 하면 보조인덱스 -> 클러스터드인덱스를 타게 되는데, 
    처음 보조인덱스로 조회시에 500만건을 Scan(M또는 F)하고 그 이후에 500만건에 대해서 랜덤 I/O를 수행해야한다.
- 그러나 email과 같이 카디널리티가 높은 컬럼이 있다고 하면, 세컨더리 인덱스 1건만 찾고 해당하는 클러스터드인덱스를 찾으면 되서 매우 접근속도가 빠르다.



