# 251104

### Spring Security Architecture

- SecurityContextHolder

  - 누가 인증되었는지 디테일한 정보를 담고있음
  - SecurityContext를 담고있음
  - <img width="486" height="179" alt="Image" src="https://github.com/user-attachments/assets/a7789ecb-846f-4212-8e6c-d845510aca30" />
  - Spring Security는 SecurityContextHolder가 어떻게 채워지는지는 신경쓰지 않음
  - 단순히, 값이 만약 내부적으로 있다면, 현재 인증된 사용자로서 사용함

  ```
  SecurityContext context = SecurityContextHolder.createEmptyContext();
  Authentication authentication =
      new TestingAuthenticationToken("username", "password", "ROLE_USER");
  context.setAuthentication(authentication);
  
  SecurityContextHolder.setContext(context);
  ```

  - SecurityContextHolder는 ThreadLocal을 내부적으로 사용
    - 따라서 동일한 스레드에서는 SecurityConetxt를 가져다 사용할 수 있음
    - FilterChainProxy에서는 Thread가 사용된 이후에 SecurityContext를 항상 clear하기때문에 ThreadLocal을 안전하게 사용가능함
    - Application별로 Thread를 사용하는 방식은 다를 수 있음
      - 이에 따라 SecurityContextHolder의 Mode를 통해 변경 가능
      - 대부분의 어플리케이션은 디폴트 모드를 변경 X

- SecurityContext

  - 내부에 Authentication을 가지고 있음
  - SecurityContextHolder로부터 접근 가능

- Authentication

  - 현재 인증된 유저로서 사용
  - AuthenticationManager에게 인증정보를 전달하기 위한 객체로서 사용
    - 이 경우엔, isAuthenticated()가 false이다.
    - 아직 인증이 완료가 되지 않은 객체이므로 
  - 아래 3개를 포함한다.
    - principal
      - 사용자를 식별
      - username /password 인증시에 UserDetails의 Instance로 사용
    - credentials
      - password를 상징
      - 사용자 인증 후 제거됨
        - 보안떄문
    - authorities
      - 권한 설정

- GrantedAuthority

  - Authentication 객체로부터 가져올 수 있음
  - principal에게 부여된 권한을 뜻함
  - roles로 표현
    - 웹인가, 메서드 호출권한, 도메인 오브젝트 권한 등을 구성에 사용됨
    - username /password 방식의 인증에서는 UserDetailsService가 주로 사용됨
  - 애플리케이션 전체에 적용되는 권한이지 특정 도메인에 국한되어 사용되지 않음

- AuthenticationManager

  - Spring Security의 내부 필터가 인증을 수행하는 방식을 구성하는 API
  - Spring Security 내부의 필터에 의해서 AuthenticationManager가 호출되고, 반환된 Authenticaton 객체는 SecurityContextHolder에 설정됨
  - ProviderManager가 일반적인 구현
    - AuthenticationManger의 구현은 아무것이나 가능함

- ProviderManager

  - AuthenticatonManager의 가장 일반적 구현형태

  - AuthenticatonProvider를 내부적으로 지니고 있음

    - AuthenticatonProvider들은 인증이 성공인지 실패인지 아니면 결정할수 없는지에 대한 정보를 지니고 있음
    - 그 어떤 AuthenticatonProvider도 인증을 수행하지 못하면 ProviderNotFoundException을 던짐

  - Optioinal하게 AuthenticationManager를 선택적 상위 AuthenticatonManger로 구성가능

    - 어떠한 AuthenticatonProvider도 인증할 수 없는 경우 참조

    - 상위 AuthenticationManager는 ProviderManger로 대게 구성

      <img width="637" height="305" alt="Image" src="https://github.com/user-attachments/assets/29c82115-9108-4ffa-92c7-0ab4405a1412" />

      - SecurityFilterChain 인스턴스를 여러개 두는 경우 위와 같이 ProviderManager가 복수 개수인 경우가 흔함
        - 각 SecurityFilterChain에서 ProviderManager를 달리 써야하는 경우

    - 인증이 성공한다고 해도, ProviderManager는 AuthenticationProvider가 인증을 끝낸 후 Authentication 객체를 반환하면, 기본적으로 비밀번호를 삭제함

      - CredentailsContainer Interface를 통해 삭제

        - UsernamePasswordAuthenticationToken 등이 해당 인터페이스를 구현하고 있음

        - 만약, 아래와 같이 UserDetails를 Redis나 CaffeineCache에 저장한다면?

          - ```java
            // 인증 시 캐시에서 유저 조회
            UserDetails cachedUser = userCache.get(username);
            if (cachedUser == null) {
                cachedUser = userDetailsService.loadUserByUsername(username);
                userCache.put(username, cachedUser);
            }
            
            ```

          - ProviderManager가 cachedUser에 대해 삭제함 

          - 즉 캐시된 객체는 비밀번호가 없는 상태가 됨.

          - 따라서 캐시에 넣기 전에 해당 객체를 return할때, AuthenticationProvider에서 복제해서 반환하는 방법을 고려해야함

            ```
            User safeCopy = new User(user.getUsername(), "", user.getAuthorities());
            return new UsernamePasswordAuthenticationToken(safeCopy, null, user.getAuthorities());
            
            ```

            

- AuthenticationProvider

  - ProviderManager에 다양한 AuthenticationProvider를 주입가능
  - 각 AuthenticationProvider는 특정한 인증을 각각 수행
  - DaoAuthenticationProvider가 username/password 기반 인증을 수행

- AuthenticationEntryPoint

  - client의 인증정보에 요청에 대한 Http Response를 응답
  - Authorization Header등이 포함되지 않을 경우에, AuthenticationEntryPoint를 구현해서 redirect login Page 또는 WWW-Authenticate Header등을 포함해서 보낼 수 있음
    - 첫 요청부터 Authorization을 Header에 실었다면 AuthenticaitonEntrypoint는 호출되지 않음

- AbstractAuthenticationProcessingFilter

  - crendential이 인증되기 전에, AuthenticationEntryPoint를 이용해서 'credential'을 Spring은 요청한다.
  - 그 이후 AbstractAuthenticatinoProcessingFilter가 동작
  - HttpServletRequest로부터 'Authentication' 객체를 생성
  - AbstractAuthenticationProcessingFilter의 하위 클래스가 무엇이냐에 따라서 Authentication의 종류가 달라짐
    - UsernamePasswordAuthenticationFilter는 UsernamePasswordAuthenticationToken을 생성한다.
  - 위와 같이 생성된 Authentcation 객체는 AuthenticationManager에게 전달됨
  - 인증 실패시
    - SecutityContextHodler가 클리어
    - RememberMeService.loginFailed가 호출
    - AuthenticationFailureHandler가 호출
  - 인증 성공시 
    - SessionAuthenticationStrategy
    - SecurityContextHodler가 보안 컨텍스트에 설정
    - RemeberMeService.loginSuccess가 호출
    - ApplicationEventPublisher가 InteractiveAuthenticationSuccessEvent를 게시
    - AuthenticationSuccessHandler가 호출

참고

https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html