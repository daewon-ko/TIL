# 251117

- Cookie
  - 최대 4KB용량을 가진 작은 양의 데이터 / 문자열만 저장가능
  - 쿠키는 HTTP 프로토콜의 일부로 정의되어있음
  - Persistent Cookie
    - 만료일까지 유저 디스크에 저장되며 만료일 지나면 삭제 
  - Session Cookie
    - 브라우저가 열려있는 동안만 유지되며 브라우저가 닫히면 영구적으로 삭제
  - Secure / HttpOnly Option
  - Secure
    - HTTPS 연결을 통해서만 쿠키가 전송되게끔 함
    - 데이터가 암호화되어 전송됨
  - HttpOnly
    - 웹페이지에 포함된 Javascript등의 스크립트 언어를 통해 쿠키의 값을 읽거나 수정할 수 없음을 의미
    - 해당 제한을 통해, 공격자의 악의적 스크립트 공격을 방어 가능
    - 해당 쿠키는 오로지 서버와의 HTTP 통신을 통해서만 서버에 전송가능
  - Cookie생성시 자동으로 Request Header에 포함됨
- LocalStorage
  - 쿠키와 달리 HTTP를 통해 데이터를 주고받을 필요가 없음
  - 사용자의 로컬 디스크에 저장되어 있으면, 인터넷이 끊어진다하더라도 데이터가 삭제되지 않음
  - 만료시간에 제한이 없으며 대략 5 ~ 10MB의 용량을 가짐
  - 사용자가 명시적으로 지우거나 브라우저의 캐시/로컬데이터를 클리어하기전까지 남아있음
  - Javascript의 Object도 저장가능
  - 동일한 Origin(동일 프로토콜, 도메인, 포트)를 공유하는 모든 탭/ 윈도우에서 공유됨
- SessionStorage
  - 탭 / 윈도우 단위로 세션 스토리지가 생성되며 각각은 독립적으로 동작
  - 브라우저 종료시 삭제됨

---



```

    Server에서 Client로 Token 전달
        Client에서 로그인 요청이 들어오고, id/pw가 유효하다면 클라이언트로 토큰을 전달해줘야 할 것이다
        이때 Access Token은 ResponseBody에, Refresh Token은 Cookies에 담아서 전달한다
        Cookie에는 'HttpOnly, Secure, SameSite(Lax)' 옵션을 설정해준다
            HttpOnly = true 를 사용해서 XSS를 예방한다
            Secure = true 를 사용해서 HTTPS 프로토콜에서만 요청을 보낼 수 있게 설정한다
            SameSite = Lax 를 사용해서 몇몇 예외 사항을 제외하고 Cross-Site에서 쿠키를 사용할 수 없게 한다
    Client에서 토큰 저장
        서버로부터 넘겨받은 Access Token은 in-memory에 저장한다. 즉, 프론트에서 특정 variable을 만들고 거기에 Access Token을 담는다
        (ex. const accessToken = response.body.get("accessToken");)
            이 경우 유저가 페이지를 새로고침 하거나 사이트를 나간다면 곧바로 AccessToken이 사라지겠지만, 이를 위해 Cookie에 Refresh Token을 설정해주었으므로 전혀 상관이 없다
    Refresh Token을 사용해서 Access Token 재발급
        만약 유저의 Access Token이 만료되었거나 사라졌다면, Request를 보낼 때 자동으로 쿠키에 Refresh Token이 포함되었을 것이므로 Access Token을 재발급 받을 수 있다
        이때, Access Token을 재발급 받을 때 RTR(Refresh Token Rotation)를 적용해서 Refresh Token도 새로 발급해주면 훨씬 더 안전하게 사용할 수 있다

```

